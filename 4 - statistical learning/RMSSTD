### RMSSTD ###
# Authors: Joe Cauteruccio, Jessie Li, Andrew West
# Yale University: Department of Statistics
# Reduced version for Yale NUS Hackaton: Diego Manya

gen_cutmat <- function(clus_out, mdim) {
  cut_mat <- matrix(nrow = mdim, ncol = mdim)
  for (i in mdim:1){
    cut_mat[, i] <- cutree(clus_out,k=i)
  }
  return(cut_mat)
}

affected.rows <- function(object.merge){
  x <- object.merge
  list.affected.rows <- list()
  tot.cat <- nrow(x)+1
  cluster.mat <- matrix(0, nrow=nrow(x), ncol=tot.cat)
  cluster.mat[nrow(x), -x[1, ]] <- 1 
  for (i in 2:nrow(x)){
    cluster.mat[tot.cat-i, ] <- cluster.mat[tot.cat+1-i, ]
    if (sum(sign(x[i, ])) == -2) cluster.mat[tot.cat-i, -x[i, ]] <- i
    if (sum(sign(x[i, ])) == 0){
      cluster.mat[tot.cat-i, -x[i, 1]] <- x[i, 2]
      cluster.mat[tot.cat-i, cluster.mat[tot.cat-i, ] == x[i, 2]] <- i
    }
    if (sum(sign(x[i, ])) == +2){
      cluster.mat[tot.cat-i, cluster.mat[tot.cat-i, ] == x[i, 1]] <- i
      cluster.mat[tot.cat-i, cluster.mat[tot.cat-i, ] == x[i, 2]] <- i
    }
  }
  
  for (i in 1:nrow(cluster.mat)) list.affected.rows[[i]] <- which(cluster.mat[i, ] == (tot.cat-i))
  return(list(cluster.mat, list.affected.rows))
}

RMSSTD_FUNC <- function(mod_dat, row_v, dim_obs){
  RMSSTD_vec <- rep(NA, dim_obs)
  RMSSTD_vec[dim_obs] <- 0
  
  for (i in (dim_obs - 1):1) { 
    x_bar_k <- apply(mod_dat[row_v[[i]], ], 2, mean)
    w_k <- sum(apply(mod_dat[row_v[[i]], ], 1, function(x) (dist(rbind(x, x_bar_k))^2))) 
    RMSSTD_vec[i] <- sqrt(w_k/(dim(mod_dat)[2]*(length(row_v[[i]]) - 1)))
  }
  
  return(RMSSTD_vec)
  
}

## Find the cluster distance ##
cluster.dis <- function(data, hclust.obj, SPRS_V){
  meth <- hclust.obj$method
  cd_vec <- rep(0, nrow(data)-1)
  cluster.mat <- affected.rows(hclust.obj$merge)[[1]]
  affected.rows <- affected.rows(hclust.obj$merge)[[2]]
  
  if (meth == "ward") cd_vec <- SPRS_V
  
  if (meth == "average"){
    for (i in 1:length(cd_vec)){
      merged.set <- hclust.obj$merge[nrow(data)-i, ]
      if (sum(sign(merged.set)) == -2){
        temp.1 <- -merged.set[1]
        temp.2 <- -merged.set[2]
      }
      
      if (sum(sign(merged.set)) == 0){
        temp.1 <- -merged.set[sign(merged.set) == -1]
        temp.2 <- which(cluster.mat[nrow(data)-merged.set[sign(merged.set) == 1], ] == merged.set[sign(merged.set) == 1])
      }
      
      if (sum(sign(merged.set)) == 2){
        temp.1 <- which(cluster.mat[nrow(data)-merged.set[1], ] == merged.set[1])
        temp.2 <- which(cluster.mat[nrow(data)-merged.set[2], ] == merged.set[2])
      }
      
      each.dis <- rep(0, length(temp.1)*length(temp.2))
      temp.sum <- 0
      for (j in 1:length(temp.1)){
        for (k in 1:length(temp.2)){
          temp.sum <- temp.sum+dist(rbind(data[temp.1[j], ], data[temp.2[k], ]))
        }
      }
      cd_vec[i] <- temp.sum/(length(temp.1)*length(temp.2))
    }
  }
  
  if (meth == "single"){
    for (i in 1:length(cd_vec)){
      merged.set <- hclust.obj$merge[nrow(data)-i, ]
      if (sum(sign(merged.set)) == -2){
        temp.1 <- -merged.set[1]
        temp.2 <- -merged.set[2]
      }
      
      if (sum(sign(merged.set)) == 0){
        temp.1 <- -merged.set[sign(merged.set) == -1]
        temp.2 <- which(cluster.mat[nrow(data)-merged.set[sign(merged.set) == 1], ] == merged.set[sign(merged.set) == 1])
      }
      
      if (sum(sign(merged.set)) == 2){
        temp.1 <- which(cluster.mat[nrow(data)-merged.set[1], ] == merged.set[1])
        temp.2 <- which(cluster.mat[nrow(data)-merged.set[2], ] == merged.set[2])
      }
      
      each.dis <- matrix(0, nrow=length(temp.1), ncol=length(temp.2))
      for (j in 1:length(temp.1)){
        for (k in 1:length(temp.2)){
          each.dis[j, k] <- dist(rbind(data[temp.1[j], ], data[temp.2[k], ]))
        }
      }
      cd_vec[i] <- min(each.dis)
    }
  }
  
  if (meth == "complete"){
    for (i in 1:length(cd_vec)){
      merged.set <- hclust.obj$merge[nrow(data)-i, ]
      if (sum(sign(merged.set)) == -2){
        temp.1 <- -merged.set[1]
        temp.2 <- -merged.set[2]
      }
      
      if (sum(sign(merged.set)) == 0){
        temp.1 <- -merged.set[sign(merged.set) == -1]
        temp.2 <- which(cluster.mat[nrow(data)-merged.set[sign(merged.set) == 1], ] == merged.set[sign(merged.set) == 1])
      }
      
      if (sum(sign(merged.set)) == 2){
        temp.1 <- which(cluster.mat[nrow(data)-merged.set[1], ] == merged.set[1])
        temp.2 <- which(cluster.mat[nrow(data)-merged.set[2], ] == merged.set[2])
      }
      
      each.dis <- matrix(0, nrow=length(temp.1), ncol=length(temp.2))
      for (j in 1:length(temp.1)){
        for (k in 1:length(temp.2)){
          each.dis[j, k] <- dist(rbind(data[temp.1[j], ], data[temp.2[k], ]))
        }
      }
      cd_vec[i] <- max(each.dis)
    }
  }
  
  if (meth == "mcquitty"){
    print("Mcquitty agglomeration for cluster distance metric not currently supported")
  }
  
  if (meth == "median"){
    print("Median agglomeration for cluster distance metric not currently supported")
  }
  
  if (meth == "centroid"){
    print("Centroid agglomeration for cluster distance metric not currently supported")
  } 
  
  return(cd_vec) 
}


####
hclus_eval <- function(data_m, dist_m = 'euclidean', clus_m = 'ward', plot_op = T, dist_cust = NA){
  
  output_list <- list()
  
  ## Some Initial Calculations
  
 ### END INITIAL CALCULATIONS
  
  ### Create Distance matrix and Clustering ###
  Info <- paste('Creating Distance Matrix using', dist_m)
  print(Info)
  
    if (dist_m == 'custom' & !is.na(dist_cust)) {dist1 <- dist_cust} 
    else dist1 <- dist(data_m, method= dist_m)

  
  Info <- paste('Clustering using', clus_m)
  print(Info)
  
  clust1 <- hclust(dist1, method = clus_m)
 
  print('Clustering Complete. Access the Cluster object in first element of output')
  
  output_list[[1]] <- clust1
  
  
  rs_out <- affected.rows(clust1$merge)
  
  me <- gen_cutmat(clust1, dim(data_m)[1])
  rs <- rs_out[[2]]

  # Calculate Metrics #
  
  print('Calculating RMSSTD')
  output_list[[2]] <- RMSSTD_FUNC(data_m, rs, dim(data_m)[1])
  print('RMSSTD Done. Access in Element 2')

  ylim_n <- max(output_list[[2]])

  if (plot_op == T){
  plot(lines(output_list[[2]], col = 'blue', lwd=3, ylim = c(0, ylim_n))
  legend('topright', c('RMSSTD'), lty = c(1),
  col = c('red'))
  }

  return(output_list)  

}
